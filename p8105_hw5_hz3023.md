p8105_hw5_hz3023
================
Huiyi Zhu
2025-11-14

## Prepare

``` r
library(tidyverse)
```

    ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
    ## ✔ dplyr     1.1.4     ✔ readr     2.1.5
    ## ✔ forcats   1.0.1     ✔ stringr   1.5.2
    ## ✔ ggplot2   4.0.0     ✔ tibble    3.3.0
    ## ✔ lubridate 1.9.4     ✔ tidyr     1.3.1
    ## ✔ purrr     1.1.0     
    ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
    ## ✖ dplyr::filter() masks stats::filter()
    ## ✖ dplyr::lag()    masks stats::lag()
    ## ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors

``` r
library(broom)
```

## Problem 1

``` r
birthday = function(n) {
    days = sample(1:365, size = n, replace = TRUE)
    length(unique(days))<n
}
set.seed(123)

set.seed(20)
result =
  expand_grid(
    group_size = 2:50,
    iter = 1:10000)|>
  mutate(share_bday = map_lgl(group_size, birthday))|>
  group_by(group_size) |>
  summarize(prob_sharebday = mean(share_bday))
```

``` r
result |>
  ggplot(
    aes(x = group_size, 
        y = prob_sharebday)) +
  geom_line() +
  geom_point() +
  labs(
    x = "Group size",
    y = "Probability of shared birthday",
    title = "Group size and Probability of shared birthday"
  )
```

![](p8105_hw5_hz3023_files/figure-gfm/unnamed-chunk-3-1.png)<!-- -->

In this plot we can see that the probability of at least two people
sharing a birthday increase when group size grows. When the group size
reaches near 25, the probability exceeds 50%. After about 50 people, the
probability is very close to 1, which indicates that two people shared a
birthday are almost guaranteed.

## Problem 2

``` r
sim_ttest = function(mu){
  x=rnorm(n = 30, mean = mu, sd = 5)
  ttest=t.test(x, mu=0)
  tidy(ttest) |> 
    select(estimate, p.value) |> 
    rename(mu_hat=estimate) |> 
    as_tibble()
}
set.seed(20)
results =
  expand_grid(
    true_mu=0:6,
    iter = 1:5000) |>
  mutate(
    output= map(true_mu, sim_ttest)) |>
  unnest(output)
```

``` r
power_results =
  results |>
  mutate(reject = p.value < 0.05) |>
  group_by(true_mu) |>
  summarize(power = mean(reject))

power_results |>
  ggplot(aes(x = true_mu, y = power)) +
  geom_line() +
  geom_point() +
  labs(
    x = expression("True value of " ~ mu),
    y = "Power (proportion of rejection Null)",
    title = "Power of one-sample t-test"
  ) 
```

![](p8105_hw5_hz3023_files/figure-gfm/unnamed-chunk-5-1.png)<!-- -->

In this plot, the power increases as the true value of $\mu$ increases.
When $\mu = 0$, the power is below 0.125, and by the time $\mu = 4$, the
power is already close to 1.

``` r
avg_mu =
  results |>
  group_by(true_mu) |>
  summarize(
    mean_mu_hat = mean(mu_hat)
  )

ggplot(avg_mu, aes(x = true_mu, y = mean_mu_hat)) +
  geom_point() +
  geom_line() +
  labs(
    x = expression("True value of " ~ mu),
    y = expression("Average of " ~ hat(mu))
  )
```

![](p8105_hw5_hz3023_files/figure-gfm/unnamed-chunk-6-1.png)<!-- -->

``` r
avg_mu_reject =
  results |>
  group_by(true_mu) |>
  summarize(
    mean_mu_hat_reject = mean(mu_hat[ p.value < 0.05]),
  )
ggplot(avg_mu_reject, aes(x = true_mu, y = mean_mu_hat_reject)) +
  geom_point() +
  geom_line() +
  labs(
    x = expression("True value of " ~ mu),
    y = expression("Average of " ~ hat(mu) ~ " | reject")
  )
```

![](p8105_hw5_hz3023_files/figure-gfm/unnamed-chunk-6-2.png)<!-- -->

``` r
combined =
  left_join(avg_mu, avg_mu_reject, by = "true_mu")
ggplot(combined, aes(x = true_mu)) +
  geom_line(aes(y = mean_mu_hat,color = "All samples")) +
  geom_point(aes(y = mean_mu_hat,color = "All samples")) +
  geom_line(aes(y = mean_mu_hat_reject,color = "Reject only")) +
  geom_point(aes(y = mean_mu_hat_reject,color = "Reject only")) +
  labs(
    x = expression("True value of " ~ mu),
    y = expression("Average " ~ hat(mu)),
    title = expression("Average " ~ hat(mu) ~ " across all samples vs. only rejected samples"),
  )
```

![](p8105_hw5_hz3023_files/figure-gfm/unnamed-chunk-6-3.png)<!-- -->

No, the sample average of $\mu$̂ among rejected test is not
approximately equal to the true $\mu$. Because the rejection only
happens when $\mu$̂ is far from 0.

## Problem 3

``` r
homicides =
  read_csv("https://raw.githubusercontent.com/washingtonpost/data-homicides/master/homicide-data.csv")
```

    ## Rows: 52179 Columns: 12
    ## ── Column specification ────────────────────────────────────────────────────────
    ## Delimiter: ","
    ## chr (9): uid, victim_last, victim_first, victim_race, victim_age, victim_sex...
    ## dbl (3): reported_date, lat, lon
    ## 
    ## ℹ Use `spec()` to retrieve the full column specification for this data.
    ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.

The dataset contains 52179 observations and 12 variables. Key variables
include the date the homicide was reported victima’ name race, age, and
sex, the city and state where the homicide occurred, and the case
disposition.

``` r
new=
  homicides |> 
  mutate(
    city_state = str_c(city, ", ", state),
    unsolved = disposition %in% c("Closed without arrest", "Open/No arrest"))|>
  group_by(city_state) |>
  summarize(
    total = n(),
    unsolved_homicides = sum(unsolved)
  )
```

``` r
new_homicides =
  homicides |>
  mutate(
    city_state = str_c(city, ", ", state),
    unsolved = disposition %in% c("Closed without arrest", "Open/No arrest"))

baltimore =
  new_homicides |>
  filter(city == "Baltimore", state == "MD") |>
  summarize(
    total = n(),
    unsolved = sum(unsolved))

baltimore_test =
  prop.test(
    x = baltimore$unsolved,
    n = baltimore$total)

baltimore_tidy = tidy(baltimore_test) |> 
  select(estimate, conf.low, conf.high)
baltimore_tidy
```

    ## # A tibble: 1 × 3
    ##   estimate conf.low conf.high
    ##      <dbl>    <dbl>     <dbl>
    ## 1    0.646    0.628     0.663

``` r
city=
  new_homicides |>
  mutate(
    city_state = str_c(city, ", ", state),
    unsolved = disposition %in% c("Closed without arrest", "Open/No arrest")
  ) |>
  group_by(city_state) |>
  summarize(
    total = n(),
    unsolved = sum(unsolved))
city|>
  mutate(
    test = map2(unsolved, total, ~ prop.test(.x, .y)),
    tidy = map(test, tidy)) |>
  unnest(tidy) |>
  select(city_state, total, unsolved, estimate, conf.low, conf.high) 
```

    ## Warning: There was 1 warning in `mutate()`.
    ## ℹ In argument: `test = map2(unsolved, total, ~prop.test(.x, .y))`.
    ## Caused by warning in `prop.test()`:
    ## ! Chi-squared approximation may be incorrect

    ## # A tibble: 51 × 6
    ##    city_state      total unsolved estimate conf.low conf.high
    ##    <chr>           <int>    <int>    <dbl>    <dbl>     <dbl>
    ##  1 Albuquerque, NM   378      146    0.386    0.337     0.438
    ##  2 Atlanta, GA       973      373    0.383    0.353     0.415
    ##  3 Baltimore, MD    2827     1825    0.646    0.628     0.663
    ##  4 Baton Rouge, LA   424      196    0.462    0.414     0.511
    ##  5 Birmingham, AL    800      347    0.434    0.399     0.469
    ##  6 Boston, MA        614      310    0.505    0.465     0.545
    ##  7 Buffalo, NY       521      319    0.612    0.569     0.654
    ##  8 Charlotte, NC     687      206    0.300    0.266     0.336
    ##  9 Chicago, IL      5535     4073    0.736    0.724     0.747
    ## 10 Cincinnati, OH    694      309    0.445    0.408     0.483
    ## # ℹ 41 more rows
